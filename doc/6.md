## 基本的なテーブル作成
```postgres
CREATE TABLE logs (
  log_id serial PRIMARY KEY,
  user_name varchar(50),
  description text,
  log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
);
CREATE INDEX idx_logs_log_ts ON logs USING btree (log_ts);
```

上記では、log_idをserialを利用していましたが、
シーケンスオブジェクトを使用して、
既存のlog_id列を新しいIDENTITY構成に変換できます。（version10以降から）
```postgres
DROP SEQUENCE logs_log_id_seq CASCADE;
ALTER TABLE logs
    ALTER COLUMN log_id ADD GENERATED BY DEFAULT AS IDENTITY;

# もしすでにレコードが存在している場合は、重複を防ぐ必要がある。
# ここでは、2000から始めるようにする。
ALTER TABLE logs
    ALTER COLUMN log_id RESTART WITH 2000;

# もし、新しいテーブルから始める場合は、下記のようになる。
CREATE TABLE logs (
  log_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_name varchar(50),
  description text,
  log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
);
```

### serialとIDENTITYの違い
- IDENTITY構造の主な利点は、IDが常に特定のテーブルに関連付けられるため、値の増分とリセットがテーブルで管理されることです。
- シリアルは、他のテーブルで再利用されるかどうかに関係なく、不要になったときに手動で削除する必要があるシーケンスオブジェクトを作成します。


##  継承されたテーブル
親子テーブルの設計は、データの分割に最適です。

継承されないもの
- 主キー制約
- 外部キー制約
- 一意性制約
- インデックス

```postgres
CREATE TABLE logs_2011(primary key(log_id)) INHERITS (logs);
CREATE INDEX idx_logs_2011_log_ts ON logs USING btree(log_ts);
# チェック制約を定義して、データを2011年に制限する。
ALTER TABLE logs_2011
  ADD CONSTRAINT chk_y2011 CHECK (log_ts BETWEEN '2011-01-01 00:00:00'::timestamptz AND '2011-12-31 23:59:59'::timestamptz);
```

## 分割テーブル
継承されたテーブルとパーティションテーブルの主な違い
- パーティションテーブルグループは宣言を使用して作成されます パーティション構文CREATE TABLE .. PARTITION BY RANGE ..。
- パーティションを使用すると、データをコアテーブルに挿入でき、一致するパーティションに自動的に再ルーティングされます。  
  これは、子テーブルにデータを挿入するか、データを子テーブルに再ルーティングするトリガーが必要な継承テーブルの場合には当てはまりません。
- パーティション内のすべてのテーブルには、まったく同じ列が必要です。  
  これは、子テーブルが親テーブルにない追加の列を持つことができる継承されたテーブルとは異なります。
- 各パーティションテーブルは、単一のパーティショングループに属しています。内部的には、親テーブルを1つだけ持つことができます。  
  一方、継承されたテーブルは、複数のテーブルから列を継承できます。
- パーティションの親は、プライマリキー、一意のキー、またはインデックスを持つことはできませんが、子パーティションは持つことができます。  
  継承テーブルテーブルでは、親と各子が主キーを持つことができ、主キーはテーブル内で一意であるだけでよく、必ずしも継承されたすべての子で一意である必要はありません。
- 継承されたテーブルとは異なり、親パーティションテーブルには 独自の行。  
  すべての挿入は一致する子パーティションにリダイレクトされ、一致する子パーティションが使用できない場合、エラーがスローされます。
```postgres
DROP TABLE IF EXISTS logs CASCADE;

# 作成（パーティションテーブル）
CREATE TABLE logs (
  log_id int GENERATED BY DEFAULT AS IDENTITY,
  user_name varchar(50),
  description text,
  log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
) PARTITION BY RANGE (log_ts);

# 作成（子パーティションテーブル）
CREATE TABLE logs_2011 PARTITION OF logs FOR VALUES FROM ('2011-1-1') TO ('2012-1-1') ;
CREATE TABLE logs_2020 PARTITION OF logs FOR VALUES FROM ('2020-1-1') TO ('2021-1-1') ;
CREATE INDEX idx_logs_2011_log_ts ON logs_2011 USING btree(log_ts);
CREATE INDEX idx_logs_2020_log_ts ON logs_2020 USING btree(log_ts);
ALTER TABLE logs_2011 ADD CONSTRAINT pk_logs_2011  PRIMARY KEY (log_id);
ALTER TABLE logs_2020 ADD CONSTRAINT pk_logs_2020  PRIMARY KEY (log_id);
```

## ログなしのテーブル
冗長性を必要としないテーブルを作る場合に、ログを記憶しないテーブルを作ることができます。
```postgres
CREATE UNLOGGED TABLE web_sessions (
	session_id text PRIMARY KEY,
	add_ts timestamptz,
	upd_ts timestamptz,
	session_state xml);

# ログなしをログ付きテーブルに変更する
ALTER TABLE web_sessions SET LOGGED;
```

## タイプ
タイプを作成すると、カラム追加などの場合にタイプ側を変更することで、タイプを利用して作られたテーブルのカラムが変更される。
```postgres
# typeを使用してテーブルを作成する。(pgAdminのデータ型に作成される)
CREATE TYPE basic_user AS (user_name varchar(50), pwd varchar(10));
CREATE TABLE super_users OF basic_user (CONSTRAINT pk_su PRIMARY KEY (user_name));

# カラム追加
ALTER TYPE basic_user ADD ATTRIBUTE phone varchar(10) CASCADE;
```

## 制約
### 外部キー制約
```postgres
SET search_path=census, public;
ALTER TABLE facts ADD CONSTRAINT fk_facts_1 FOREIGN KEY (fact_type_id) REFERENCES lu_fact_types (fact_type_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX fki_facts_1 ON facts (fact_type_id); 
```

### 固有の制約
一意のキー制約のない一意のインデックスもnull値を持つことができ、さらにその定義で関数を使用できます
```postgres
ALTER TABLE logs_2011 ADD CONSTRAINT uq UNIQUE (user_name,log_ts);
```

### 制約をチェック
チェック制約は 各行のフィールドまたはフィールドのセットで満たす必要がある条件。
```postgres
ALTER TABLE logs ADD CONSTRAINT chk CHECK (user_name = lower(user_name));
```

## 除外制約
除外制約により、 追加の演算子を組み込んで、等価演算子では満たすことができない一意性を適用します。
```postgres
# 拡張として「btree_gist」をインストールする必要がある。

# 同じ部屋の予約が重複しないようにする
CREATE TABLE schedules(id serial primary key, room int, time_slot tstzrange);
ALTER TABLE schedules ADD CONSTRAINT ex_schedules EXCLUDE USING gist (room WITH =, time_slot WITH &&);

# 配列ブロックの重複を防ぐ
CREATE TABLE room_blocks(block_id integer primary key, rooms int[]);
CREATE EXTENSION IF NOT EXISTS intarray;
ALTER TABLE room_blocks ADD CONSTRAINT ex_room_blocks_rooms EXCLUDE USING gist(rooms WITH &&);
```
## インデックス
一つのテーブルで、混合したインデックスを利用することができる。
テーブル（外部テーブルを除く）とマテリアライズドビューにインデックスを作成できます。

indexの種類
- B-Tree
> リレーショナルデータベースで一般的な汎用インデックス。
- BRIN
> Bツリーなどのインデックスを使用するとスペースを取りすぎてメモリに収まらない非常に大きなテーブル用に設計されています。  
> version9.4以降で導入されました。  
> BRINインデックスは、Bツリーや他のインデックスよりもはるかに小さく、構築が高速です。ただし、使用が遅く、主キーやその他の特定の状況では使用できません。
- GiST
> FTS、空間データ、科学データ、非構造化データ、および階層データ用に最適化されたインデックス。
- GIN
> Generalized Inverted Index（GIN）は組み込みの全文検索向けPostgreSQLのバイナリjsonデータ型。
> GINが必要とする追加のレプリケーションは、インデックスが大きく、インデックスの更新が同等のGiSTインデックスよりも遅いことを意味します。  
> また、各インデックス行は特定のサイズに制限されているため、GINを使用して大きなhstoreドキュメントやテキストなどの大きなオブジェクトにインデックスを付けることはできません。
- SP-GiST
> 空間分割一般化検索ツリー（SP-GiST）では、GiSTと同じ状況で使用できますが、特定の種類のデータ配布の方が高速になる場合があります。
- hash
> パフォーマンスとトランザクションの安全性の両面で、GiSTとGINがハッシュを上回っています。
- B-Tree-GiST/B-Tree-GIN
> 例えば、GISTでインデックスが付けられた列とBツリーでインデックスが付けられた列を1つのインデックスで組み合わせることができます。

## 演算子クラス
インデックスアーキテクトは、特定のデータ型に対してのみ、および特定の比較演算子に対してのみインデックスが機能することを意図しています。

```postgres
# B-Treeはどのデータ型と演算子クラスをサポートしていますか？
SELECT am.amname AS index_method, opc.opcname AS opclass_name,
  opc.opcintype::regtype AS indexed_type, opc.opcdefault AS is_default
FROM pg_am am INNER JOIN pg_opclass opc ON opc.opcmethod = am.oid
WHERE am.amname = 'btree'
ORDER BY index_method, indexed_type, opclass_name;

```
結果の一部抜粋
| index_method |    opclass_name     |        indexed_type         | is_default |
|--------------|---------------------|-----------------------------|--|
| btree        | text_ops            | text                        | t|
| btree        | text_pattern_ops    | text                        | f|
| btree        | varchar_ops         | text                        | f|
| btree        | varchar_pattern_ops | text                        | f|

text_opsをみると、is_defaultがtとなっているため、LIKE演算子は利用することができます。
ただ、ワイルドカード検索ではインデックスを利用することができません。
以下で明示的に利用できるようにする。

```postgres
# indexを作成する際に、カラム名の後にopclassを指定する
CREATE INDEX idx1 ON census.lu_tracts USING btree (tract_name text_pattern_ops);
```

>作成する各インデックスは単一のopclassに対してのみ機能することを覚えておいてください。列のインデックスで複数のopclassをカバーする場合は、個別のインデックスを作成する必要があります。

```postgres
# 同じテーブルにインデックスを2つ作成する。
CREATE INDEX idx2 ON census.lu_tracts USING btree (tract_name);
```

以上により、tract_nameは等価クエリとLIKEを使用したクエリでインデックスを有効にすることができます。

## 関数インデックス
PostgreSQLは大文字と小文字を区別するデータベースです。  
大文字と小文字を区別しない検索を実行するには、関数インデックスを作成します。
```postgres
# 関数インデックスを作成する
CREATE INDEX idx ON featnames_short 
USING btree (upper(fullname) varchar_pattern_ops);

# 関数インデックスに対してクエリをする場合は、関数クエリを利用する必要がある。
SELECT fullname FROM featnames_short WHERE upper(fullname) LIKE 'S%';
```

## 部分インデックス
部分インデックス（時々 フィルター選択されたインデックスと呼ばれる）は、事前定義されたWHERE条件に適合する行のみをカバーするインデックスです。
```postgres
CREATE TABLE subscribers (
    id serial PRIMARY KEY,
    name varchar(50) NOT NULL, type varchar(50),
    is_active boolean);

CREATE UNIQUE INDEX uq2 ON subscribers USING btree(lower(name)) WHERE is_active;

CREATE OR REPLACE VIEW vw_subscribers_current AS
SELECT id, lower(name) As name FROM subscribers WHERE is_active = true;

SELECT * FROM vw_subscribers_current WHERE name = 'sandy';
```

実行計画の結果
```
                               QUERY PLAN                               
------------------------------------------------------------------------
 Index Scan using uq2 on subscribers  (cost=0.12..8.14 rows=1 width=36)
   Index Cond: (lower((name)::text) = 'sandy'::text)
(2 rows)
```

## 複数列のインデックス
基礎となる複数の列を使用して機能インデックスを作成することもできます
```postgres
CREATE INDEX idx ON subscribers 
USING btree (type, upper(name) varchar_pattern_ops);
```
複合列のインデックスの実行検索の結果
```postgres
EXPLAIN SELECT * FROM vw_subscribers_current WHERE name = 'sandy' and name LIKE '%t%';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Index Scan using uq2 on subscribers  (cost=0.12..8.15 rows=1 width=36)
   Index Cond: (lower((name)::text) = 'sandy'::text)
   Filter: (lower((name)::text) ~~ '%t%'::text)
(3 rows)
```